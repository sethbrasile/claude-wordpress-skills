# WordPress Vulnerability Patterns Reference

This reference catalogs common WordPress security vulnerabilities with patterns to find them in code reviews. Each vulnerability includes CWE references, detection patterns, and BAD/GOOD code examples following WordPress PHP Coding Standards.

## Quick Lookup Table

| Pattern to Find | Severity | CWE | Issue |
|----------------|----------|-----|-------|
| Direct SQL interpolation in `$wpdb` methods | CRITICAL | CWE-89 | SQL Injection |
| `LIKE` without `esc_like()` | CRITICAL | CWE-89 | SQL Injection via wildcards |
| User input in `ORDER BY`/`GROUP BY` | CRITICAL | CWE-89 | SQL Injection in clauses |
| Double-calling `$wpdb->prepare()` | CRITICAL | CWE-89 | Prepared statement bypass |
| Unescaped output in HTML context | CRITICAL | CWE-79 | Cross-Site Scripting (XSS) |
| Missing output escaping in templates | CRITICAL | CWE-79 | Stored XSS |
| Missing nonce verification in forms | CRITICAL | CWE-352 | Cross-Site Request Forgery |
| Missing `permission_callback` in REST routes | CRITICAL | CWE-862 | Missing authorization |
| Missing capability check before action | CRITICAL | CWE-862 | Missing authorization |
| `current_user_can()` without post context | WARNING | CWE-863 | Incorrect authorization |
| Role checks instead of capabilities | WARNING | CWE-863 | Broken access control |
| File upload without MIME validation | CRITICAL | CWE-434 | Unrestricted file upload |
| `move_uploaded_file()` instead of WP function | CRITICAL | CWE-434 | Insecure file handling |
| `unserialize()` on user input | CRITICAL | CWE-502 | Object injection |
| Dynamic `include/require` with user input | CRITICAL | CWE-22 | Path traversal |
| Missing `basename()` on file paths | WARNING | CWE-22 | Path traversal |
| `WP_DEBUG` true in production | WARNING | N/A | Information disclosure |
| `display_errors` on in production | WARNING | N/A | Information disclosure |
| Exposed `.git` directory | CRITICAL | N/A | Source code disclosure |
| `eval()` on user input | CRITICAL | CWE-94 | Code injection |
| `exec/shell_exec/system` on user input | CRITICAL | CWE-78 | Command injection |
| Open redirect via unchecked URL | WARNING | CWE-601 | Open redirect |
| Missing `wp_safe_redirect()` | WARNING | CWE-601 | Open redirect |

## SQL Injection Patterns (CWE-89)

SQL injection occurs when user input is directly interpolated into SQL queries. WordPress provides `$wpdb->prepare()` for parameterized queries, but it's often misused.

### Direct Interpolation

```php
// ❌ BAD: Direct variable interpolation
$user_id = $_GET['user_id'];
$results = $wpdb->get_results( "SELECT * FROM {$wpdb->posts} WHERE post_author = $user_id" );

// ❌ BAD: String concatenation
$search = $_POST['search'];
$results = $wpdb->get_results( "SELECT * FROM {$wpdb->posts} WHERE post_title LIKE '%" . $search . "%'" );

// ❌ BAD: Even with sanitization, still vulnerable
$id = intval( $_GET['id'] );
$wpdb->query( "DELETE FROM {$wpdb->posts} WHERE ID = $id" ); // Still interpolated!

// ✅ GOOD: Use prepare() with placeholders
$user_id = absint( $_GET['user_id'] );
$results = $wpdb->get_results( $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE post_author = %d",
    $user_id
) );

// ✅ GOOD: Parameterized LIKE query
$search = sanitize_text_field( wp_unslash( $_POST['search'] ) );
$results = $wpdb->get_results( $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s",
    '%' . $wpdb->esc_like( $search ) . '%'
) );
```

### LIKE Clause Injection

The `LIKE` operator uses `%` and `_` as wildcards. User input must be escaped with `$wpdb->esc_like()` before adding your own wildcards.

```php
// ❌ BAD: Missing esc_like() allows wildcard injection
$search = $_GET['search'];
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s",
    '%' . $search . '%' // User can inject % or _ wildcards
);

// ❌ BAD: esc_like() after prepare placeholder
$search = $_GET['search'];
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE post_title LIKE '%%%s%%'",
    $wpdb->esc_like( $search ) // Prepare escapes the backslashes!
);

// ✅ GOOD: esc_like() before prepare, wildcards outside placeholder
$search = sanitize_text_field( wp_unslash( $_GET['search'] ) );
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s",
    '%' . $wpdb->esc_like( $search ) . '%'
);

// ✅ GOOD: Prefix search
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s",
    $wpdb->esc_like( $search ) . '%'
);
```

### ORDER BY Injection

`ORDER BY` clauses cannot be parameterized with `%s` or `%d`. Use a whitelist approach.

```php
// ❌ BAD: Direct user input in ORDER BY
$orderby = $_GET['orderby'];
$sql = "SELECT * FROM {$wpdb->posts} ORDER BY $orderby"; // Vulnerable!

// ❌ BAD: Using %s placeholder doesn't help
$orderby = $_GET['orderby'];
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} ORDER BY %s", // This adds quotes!
    $orderby
);

// ✅ GOOD: Whitelist allowed columns
$allowed_orderby = array( 'post_title', 'post_date', 'ID' );
$orderby = isset( $_GET['orderby'] ) && in_array( $_GET['orderby'], $allowed_orderby, true )
    ? $_GET['orderby']
    : 'post_date';

$sql = "SELECT * FROM {$wpdb->posts} ORDER BY $orderby DESC";

// ✅ GOOD: Whitelist with direction
$allowed_orderby = array( 'post_title', 'post_date', 'ID' );
$allowed_order = array( 'ASC', 'DESC' );

$orderby = isset( $_GET['orderby'] ) && in_array( $_GET['orderby'], $allowed_orderby, true )
    ? $_GET['orderby']
    : 'post_date';

$order = isset( $_GET['order'] ) && in_array( strtoupper( $_GET['order'] ), $allowed_order, true )
    ? strtoupper( $_GET['order'] )
    : 'DESC';

$sql = "SELECT * FROM {$wpdb->posts} ORDER BY $orderby $order";
```

### Double-Prepare Anti-Pattern

Never call `prepare()` on already-prepared SQL. This removes escaping.

```php
// ❌ BAD: Double-prepare removes escaping
$user_input = $_GET['id'];
$sql = $wpdb->prepare( "SELECT * FROM {$wpdb->posts} WHERE ID = %d", $user_input );
$results = $wpdb->get_results( $wpdb->prepare( $sql ) ); // Removes escaping!

// ✅ GOOD: Prepare once, execute directly
$user_input = absint( $_GET['id'] );
$sql = $wpdb->prepare( "SELECT * FROM {$wpdb->posts} WHERE ID = %d", $user_input );
$results = $wpdb->get_results( $sql );

// ✅ GOOD: Or pass directly without intermediate variable
$results = $wpdb->get_results( $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE ID = %d",
    absint( $_GET['id'] )
) );
```

### IN Clause Construction

Building `IN (...)` clauses requires multiple placeholders.

```php
// ❌ BAD: Direct array implode
$ids = $_POST['ids']; // Array of IDs
$sql = "SELECT * FROM {$wpdb->posts} WHERE ID IN (" . implode( ',', $ids ) . ")";

// ❌ BAD: Single placeholder for array
$ids = array_map( 'absint', $_POST['ids'] );
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE ID IN (%s)", // Wrong!
    implode( ',', $ids )
);

// ✅ GOOD: Placeholders for each value
$ids = array_map( 'absint', $_POST['ids'] );
$placeholders = implode( ', ', array_fill( 0, count( $ids ), '%d' ) );
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE ID IN ($placeholders)",
    $ids
);
$results = $wpdb->get_results( $sql );

// ✅ GOOD: Alternative with sprintf
$ids = array_map( 'absint', $_POST['ids'] );
$placeholders = implode( ', ', array_fill( 0, count( $ids ), '%d' ) );
$query = "SELECT * FROM {$wpdb->posts} WHERE ID IN ($placeholders)";
$results = $wpdb->get_results( $wpdb->prepare( $query, ...$ids ) ); // PHP 7.4+
```

### Table and Column Name Injection

Never use user input for table or column names. Use whitelisting.

```php
// ❌ BAD: User-controlled table name
$table = $_GET['table'];
$sql = "SELECT * FROM $table"; // Dangerous!

// ❌ BAD: User-controlled column name
$column = $_GET['column'];
$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE %s = %s",
    $column, // prepare() adds quotes, breaks syntax
    $_GET['value']
);

// ✅ GOOD: Whitelist table names
$allowed_tables = array(
    'posts' => $wpdb->posts,
    'users' => $wpdb->users,
);
$table_key = sanitize_key( $_GET['table'] );
$table = isset( $allowed_tables[ $table_key ] ) ? $allowed_tables[ $table_key ] : $wpdb->posts;
$sql = "SELECT * FROM $table";

// ✅ GOOD: Whitelist column names
$allowed_columns = array( 'post_title', 'post_date', 'post_author' );
$column = isset( $_GET['column'] ) && in_array( $_GET['column'], $allowed_columns, true )
    ? $_GET['column']
    : 'post_title';

$sql = $wpdb->prepare(
    "SELECT * FROM {$wpdb->posts} WHERE $column = %s",
    sanitize_text_field( wp_unslash( $_GET['value'] ) )
);
```

## Cross-Site Scripting (XSS) Patterns (CWE-79)

XSS occurs when user-controlled data is output to HTML without proper escaping. WordPress requires "late escaping" — sanitize on input, escape on output.

### Stored XSS

Data from the database that originated from user input must be escaped before output.

```php
// ❌ BAD: Outputting post meta without escaping
$user_website = get_post_meta( $post_id, 'website', true );
echo '<a href="' . $user_website . '">Visit</a>'; // XSS if malicious URL stored

// ❌ BAD: Outputting custom field
$custom_title = get_post_meta( $post_id, 'custom_title', true );
echo '<h1>' . $custom_title . '</h1>'; // XSS if HTML stored

// ✅ GOOD: Escape URL context
$user_website = get_post_meta( $post_id, 'website', true );
echo '<a href="' . esc_url( $user_website ) . '">Visit</a>';

// ✅ GOOD: Escape HTML context
$custom_title = get_post_meta( $post_id, 'custom_title', true );
echo '<h1>' . esc_html( $custom_title ) . '</h1>';
```

### Reflected XSS

Data from `$_GET`, `$_POST`, `$_REQUEST`, or `$_SERVER` must be escaped before output.

```php
// ❌ BAD: Reflecting GET parameter
$search = $_GET['s'];
echo '<p>Search results for: ' . $search . '</p>'; // XSS!

// ❌ BAD: Reflecting in attribute
$user_id = $_GET['user_id'];
echo '<div data-user="' . $user_id . '">'; // XSS in attribute!

// ✅ GOOD: Escape HTML context
$search = isset( $_GET['s'] ) ? sanitize_text_field( wp_unslash( $_GET['s'] ) ) : '';
echo '<p>Search results for: ' . esc_html( $search ) . '</p>';

// ✅ GOOD: Escape attribute context
$user_id = isset( $_GET['user_id'] ) ? absint( $_GET['user_id'] ) : 0;
echo '<div data-user="' . esc_attr( $user_id ) . '">';
```

### DOM-Based XSS

JavaScript that incorporates user input into the DOM without encoding.

```php
// ❌ BAD: PHP echoing unescaped JS variable
<script>
var userName = "<?php echo $_GET['name']; ?>"; // XSS if name contains quotes
document.getElementById('greeting').innerHTML = 'Hello, ' + userName;
</script>

// ❌ BAD: Using innerHTML with user data
<script>
var searchTerm = "<?php echo esc_js( $_GET['search'] ); ?>";
document.getElementById('results').innerHTML = 'Results for: ' + searchTerm; // Still XSS!
</script>

// ✅ GOOD: Use wp_localize_script for data passing
<?php
wp_localize_script( 'my-script', 'myData', array(
    'userName' => sanitize_text_field( wp_unslash( $_GET['name'] ) ),
) );
?>

<script>
// Access via localized object
var userName = myData.userName; // Properly JSON-encoded
document.getElementById('greeting').textContent = 'Hello, ' + userName; // textContent, not innerHTML
</script>

// ✅ GOOD: Use textContent instead of innerHTML
<script>
var searchTerm = <?php echo wp_json_encode( sanitize_text_field( wp_unslash( $_GET['search'] ) ) ); ?>;
document.getElementById('results').textContent = 'Results for: ' + searchTerm;
</script>
```

### Context-Specific Escaping Failures

Using the wrong escaping function for the output context.

```php
// ❌ BAD: HTML escaping in URL context (doesn't validate scheme)
$redirect = $_GET['redirect_to'];
echo '<a href="' . esc_html( $redirect ) . '">Next</a>'; // javascript: URLs pass through!

// ❌ BAD: Attribute escaping in HTML context (allows tags)
$content = $_POST['content'];
echo '<div>' . esc_attr( $content ) . '</div>'; // Tags pass through!

// ❌ BAD: URL escaping in JS context
echo '<script>var url = "' . esc_url( $_GET['url'] ) . '";</script>'; // Quote escaping wrong

// ✅ GOOD: URL escaping in URL context
$redirect = isset( $_GET['redirect_to'] ) ? $_GET['redirect_to'] : home_url();
echo '<a href="' . esc_url( $redirect ) . '">Next</a>'; // Validates scheme

// ✅ GOOD: HTML escaping in HTML context
$content = sanitize_text_field( wp_unslash( $_POST['content'] ) );
echo '<div>' . esc_html( $content ) . '</div>';

// ✅ GOOD: JS escaping in JS context (or better, wp_localize_script)
echo '<script>var url = ' . wp_json_encode( esc_url_raw( $_GET['url'] ) ) . ';</script>';
```

### Late Escaping Violations

Escaping before storage instead of before output.

```php
// ❌ BAD: Escaping before storage
$title = esc_html( $_POST['title'] );
update_post_meta( $post_id, 'title', $title ); // Wrong! Can't use title in other contexts

$url = esc_url( $_POST['website'] );
update_user_meta( $user_id, 'website', $url ); // Wrong! Already escaped

// ❌ BAD: Double-escaping on output
$title = get_post_meta( $post_id, 'title', true ); // Already HTML-escaped
echo '<h1>' . esc_html( $title ) . '</h1>'; // Double-escaped! Shows &amp;

// ✅ GOOD: Sanitize input, escape output
$title = sanitize_text_field( wp_unslash( $_POST['title'] ) );
update_post_meta( $post_id, 'title', $title ); // Store raw, sanitized data

$title = get_post_meta( $post_id, 'title', true );
echo '<h1>' . esc_html( $title ) . '</h1>'; // Escape once, at output

// ✅ GOOD: Different contexts from same data
$url = sanitize_url( $_POST['website'] );
update_user_meta( $user_id, 'website', $url ); // Store sanitized URL

$url = get_user_meta( $user_id, 'website', true );
echo '<a href="' . esc_url( $url ) . '">' . esc_html( $url ) . '</a>'; // Different escaping per context
```

### wp_kses Family Usage

For allowing specific HTML tags, use `wp_kses()` or `wp_kses_post()`.

```php
// ❌ BAD: Allowing all HTML with no filtering
$content = $_POST['content'];
update_post_meta( $post_id, 'bio', $content ); // Stores <script>, <iframe>, etc.

// ❌ BAD: Using wp_kses_post() on untrusted input
$content = wp_kses_post( $_POST['content'] ); // Allows too many tags for user bios!
update_user_meta( $user_id, 'bio', $content );

// ✅ GOOD: Custom allowed tags with wp_kses
$allowed_tags = array(
    'a' => array( 'href' => array(), 'title' => array() ),
    'br' => array(),
    'em' => array(),
    'strong' => array(),
);
$bio = wp_kses( wp_unslash( $_POST['bio'] ), $allowed_tags );
update_user_meta( $user_id, 'bio', $bio );

// ✅ GOOD: wp_kses_post() only for post content from trusted users
if ( current_user_can( 'edit_posts' ) ) {
    $content = wp_kses_post( wp_unslash( $_POST['content'] ) );
    update_post_meta( $post_id, 'custom_content', $content );
}
```

## CSRF Patterns (CWE-352)

Cross-Site Request Forgery allows attackers to execute state-changing actions on behalf of authenticated users. WordPress uses nonces for CSRF protection.

**See nonce-csrf-guide.md for comprehensive coverage.**

### Quick Detection

```php
// ❌ BAD: Form handler missing nonce check
function prefix_save_settings() {
    // No nonce verification!
    if ( isset( $_POST['setting'] ) ) {
        update_option( 'prefix_setting', $_POST['setting'] );
    }
}
add_action( 'admin_init', 'prefix_save_settings' );

// ✅ GOOD: Three-step form security
function prefix_save_settings() {
    if ( ! isset( $_POST['_nonce'] ) || ! wp_verify_nonce( $_POST['_nonce'], 'save_action' ) ) {
        wp_die( 'Invalid nonce' );
    }
    if ( ! current_user_can( 'manage_options' ) ) {
        wp_die( 'Insufficient permissions' );
    }
    $value = sanitize_text_field( wp_unslash( $_POST['setting'] ) );
    update_option( 'prefix_setting', $value );
}
add_action( 'admin_init', 'prefix_save_settings' );
```

## Authorization Patterns (CWE-862, CWE-863)

Missing or incorrect authorization checks allow users to perform actions they shouldn't.

**See auth-patterns.md for comprehensive coverage.**

### Missing Authorization (CWE-862)

```php
// ❌ BAD: No capability check before deletion
function prefix_delete_post() {
    $post_id = absint( $_POST['post_id'] );
    wp_delete_post( $post_id, true ); // Anyone can delete!
}
add_action( 'wp_ajax_delete_post', 'prefix_delete_post' );

// ✅ GOOD: Capability check before action
function prefix_delete_post() {
    $post_id = absint( $_POST['post_id'] );
    if ( ! current_user_can( 'delete_post', $post_id ) ) {
        wp_send_json_error( 'Insufficient permissions' );
    }
    wp_delete_post( $post_id, true );
    wp_send_json_success();
}
add_action( 'wp_ajax_delete_post', 'prefix_delete_post' );
```

### Incorrect Authorization (CWE-863)

```php
// ❌ BAD: Checking edit_posts without post context
function prefix_edit_post() {
    if ( ! current_user_can( 'edit_posts' ) ) { // Can edit ANY post?
        wp_die( 'No permission' );
    }
    $post_id = absint( $_POST['post_id'] );
    wp_update_post( array( 'ID' => $post_id, 'post_title' => $_POST['title'] ) );
}

// ✅ GOOD: Meta capability with post context
function prefix_edit_post() {
    $post_id = absint( $_POST['post_id'] );
    if ( ! current_user_can( 'edit_post', $post_id ) ) { // Checks THIS post
        wp_die( 'No permission' );
    }
    $title = sanitize_text_field( wp_unslash( $_POST['title'] ) );
    wp_update_post( array( 'ID' => $post_id, 'post_title' => $title ) );
}
```

### REST API Missing permission_callback (CWE-862)

```php
// ❌ BAD: Missing permission_callback (WP 5.5+)
register_rest_route( 'myapp/v1', '/data', array(
    'methods'  => 'POST',
    'callback' => 'prefix_handle_data',
    // No permission_callback! Anyone can POST
) );

// ✅ GOOD: Explicit permission check
register_rest_route( 'myapp/v1', '/data', array(
    'methods'             => 'POST',
    'callback'            => 'prefix_handle_data',
    'permission_callback' => function() {
        return current_user_can( 'edit_posts' );
    },
) );

// ✅ GOOD: Public read-only endpoint
register_rest_route( 'myapp/v1', '/public-data', array(
    'methods'             => 'GET',
    'callback'            => 'prefix_get_public_data',
    'permission_callback' => '__return_true', // Explicitly public
) );
```

## File Upload Vulnerabilities

File uploads are high-risk. WordPress provides secure handling functions.

### Unrestricted File Upload (CWE-434)

```php
// ❌ BAD: Direct move_uploaded_file() usage
if ( isset( $_FILES['upload'] ) ) {
    $target = WP_CONTENT_DIR . '/uploads/' . $_FILES['upload']['name'];
    move_uploaded_file( $_FILES['upload']['tmp_name'], $target ); // No validation!
}

// ❌ BAD: Only checking extension
$filename = $_FILES['upload']['name'];
$ext = pathinfo( $filename, PATHINFO_EXTENSION );
if ( 'jpg' === $ext ) { // Can be spoofed!
    move_uploaded_file( $_FILES['upload']['tmp_name'], $target );
}

// ✅ GOOD: Use wp_handle_upload() with validation
if ( ! function_exists( 'wp_handle_upload' ) ) {
    require_once( ABSPATH . 'wp-admin/includes/file.php' );
}

$uploadedfile = $_FILES['upload'];
$upload_overrides = array( 'test_form' => false );
$movefile = wp_handle_upload( $uploadedfile, $upload_overrides );

if ( $movefile && ! isset( $movefile['error'] ) ) {
    // File uploaded successfully
    $file_path = $movefile['file'];
    $file_url = $movefile['url'];
} else {
    // Error
    echo $movefile['error'];
}
```

### MIME Type Spoofing

```php
// ❌ BAD: Trusting $_FILES['type']
$allowed_types = array( 'image/jpeg', 'image/png' );
if ( in_array( $_FILES['upload']['type'], $allowed_types, true ) ) {
    // User can spoof this header!
    move_uploaded_file( $_FILES['upload']['tmp_name'], $target );
}

// ✅ GOOD: Use wp_check_filetype_and_ext() for content-based check
$filename = $_FILES['upload']['name'];
$tmp_name = $_FILES['upload']['tmp_name'];

$filetype = wp_check_filetype_and_ext( $tmp_name, $filename );
$ext = empty( $filetype['ext'] ) ? '' : $filetype['ext'];
$type = empty( $filetype['type'] ) ? '' : $filetype['type'];

if ( ! $type || ! $ext ) {
    wp_die( 'Invalid file type' );
}

// Then use wp_handle_upload()
```

### Path Traversal in Filenames

```php
// ❌ BAD: Using user filename directly
$filename = $_FILES['upload']['name']; // Could be ../../evil.php
$target = WP_CONTENT_DIR . '/uploads/' . $filename;
move_uploaded_file( $_FILES['upload']['tmp_name'], $target ); // Writes outside uploads!

// ✅ GOOD: Sanitize filename
$filename = sanitize_file_name( $_FILES['upload']['name'] );
$target = WP_CONTENT_DIR . '/uploads/' . $filename;
// Still use wp_handle_upload() for complete security
```

### Missing Capability Check

```php
// ❌ BAD: No permission check for upload
function prefix_handle_upload() {
    // Anyone can upload!
    $movefile = wp_handle_upload( $_FILES['file'], array( 'test_form' => false ) );
}
add_action( 'wp_ajax_nopriv_upload', 'prefix_handle_upload' );

// ✅ GOOD: Require capability
function prefix_handle_upload() {
    if ( ! current_user_can( 'upload_files' ) ) {
        wp_send_json_error( 'No permission to upload' );
    }

    if ( ! function_exists( 'wp_handle_upload' ) ) {
        require_once( ABSPATH . 'wp-admin/includes/file.php' );
    }

    $movefile = wp_handle_upload( $_FILES['file'], array( 'test_form' => false ) );

    if ( $movefile && ! isset( $movefile['error'] ) ) {
        wp_send_json_success( $movefile );
    } else {
        wp_send_json_error( $movefile['error'] );
    }
}
add_action( 'wp_ajax_upload', 'prefix_handle_upload' ); // Authenticated only
```

### PHP Execution in Uploads Directory

```php
// INFO: Add .htaccess to prevent PHP execution in uploads
// Create in wp-content/uploads/.htaccess:

<Files *.php>
    deny from all
</Files>

// Or in nginx:
// location ~* ^/wp-content/uploads/.*\.php$ {
//     deny all;
// }
```

## Object Injection (CWE-502)

PHP's `unserialize()` can lead to remote code execution via object injection attacks when used on untrusted input.

### Unserialize on User Input

```php
// ❌ BAD: unserialize() on POST data
$data = unserialize( $_POST['data'] ); // Critical vulnerability!

// ❌ BAD: unserialize() on cookie
$preferences = unserialize( $_COOKIE['user_prefs'] ); // Attacker controls cookies!

// ❌ BAD: Even with is_serialized() check
if ( is_serialized( $_POST['data'] ) ) {
    $data = unserialize( $_POST['data'] ); // Still vulnerable!
}

// ✅ GOOD: Use JSON instead
$data = json_decode( sanitize_text_field( wp_unslash( $_POST['data'] ) ), true );
if ( json_last_error() !== JSON_ERROR_NONE ) {
    wp_die( 'Invalid JSON' );
}

// ✅ GOOD: For cookies
$preferences = isset( $_COOKIE['user_prefs'] )
    ? json_decode( wp_unslash( $_COOKIE['user_prefs'] ), true )
    : array();
```

### Gadget Chain Risk

WordPress core and popular plugins may contain "gadget classes" that can be chained together for exploitation. Never unserialize untrusted data.

```php
// ❌ BAD: Unserializing from database without origin verification
$serialized_data = get_option( 'prefix_user_data' );
$data = unserialize( $serialized_data ); // If attacker wrote to DB, vulnerable

// ✅ GOOD: Store as JSON
update_option( 'prefix_user_data', wp_json_encode( $data ) );
$stored = get_option( 'prefix_user_data' );
$data = json_decode( $stored, true );
```

## Path Traversal (CWE-22)

Path traversal allows attackers to read or include files outside intended directories.

### Dynamic Includes

```php
// ❌ BAD: User-controlled include
$template = $_GET['template'];
include( $template . '.php' ); // Can include any file!

// ❌ BAD: With directory prefix but no validation
$template = $_GET['template'];
include( __DIR__ . '/templates/' . $template . '.php' ); // Still: ../../../wp-config.php

// ✅ GOOD: Whitelist approach
$allowed_templates = array( 'header', 'footer', 'sidebar', 'content' );
$template = isset( $_GET['template'] ) && in_array( $_GET['template'], $allowed_templates, true )
    ? $_GET['template']
    : 'content';

include( __DIR__ . '/templates/' . $template . '.php' );

// ✅ GOOD: Using basename() to strip path
$template = basename( sanitize_file_name( $_GET['template'] ) );
$file = __DIR__ . '/templates/' . $template . '.php';

if ( file_exists( $file ) ) {
    include( $file );
} else {
    wp_die( 'Template not found' );
}
```

### File Reading

```php
// ❌ BAD: User-controlled file path
$file = $_GET['file'];
$contents = file_get_contents( WP_CONTENT_DIR . '/exports/' . $file ); // Path traversal!

// ✅ GOOD: Validate filename
$file = basename( sanitize_file_name( $_GET['file'] ) );
$full_path = WP_CONTENT_DIR . '/exports/' . $file;

// Verify file is within intended directory
$real_path = realpath( $full_path );
$exports_dir = realpath( WP_CONTENT_DIR . '/exports/' );

if ( false === $real_path || 0 !== strpos( $real_path, $exports_dir ) ) {
    wp_die( 'Invalid file path' );
}

$contents = file_get_contents( $real_path );
```

## Information Disclosure

Leaking sensitive information aids attackers.

### Debug Output in Production

```php
// ❌ BAD: WP_DEBUG enabled in production
define( 'WP_DEBUG', true ); // In wp-config.php

// ❌ BAD: Displaying errors in production
ini_set( 'display_errors', 1 );
error_reporting( E_ALL );

// ✅ GOOD: Debug only in development
define( 'WP_DEBUG', false );
define( 'WP_DEBUG_LOG', false );
define( 'WP_DEBUG_DISPLAY', false );
ini_set( 'display_errors', 0 );

// ✅ GOOD: Environment-based debug
$is_dev = ( 'development' === getenv( 'WP_ENV' ) );
define( 'WP_DEBUG', $is_dev );
define( 'WP_DEBUG_LOG', $is_dev );
define( 'WP_DEBUG_DISPLAY', false );
```

### Exposed Configuration

```php
// ❌ BAD: wp-config.php accessible via web
// Ensure wp-config.php is above web root or protected

// ✅ GOOD: Block access in .htaccess
<files wp-config.php>
    order allow,deny
    deny from all
</files>

// ✅ GOOD: Move above web root
// /var/www/wordpress/ (web root)
// /var/www/wp-config.php (one level up)
```

### Verbose Error Messages

```php
// ❌ BAD: Exposing internal details in error messages
if ( ! $user ) {
    wp_die( 'User ID ' . $user_id . ' not found in database table ' . $wpdb->users );
}

// ✅ GOOD: Generic error message
if ( ! $user ) {
    wp_die( 'User not found' );
}

// ✅ GOOD: Log details, show generic message
if ( ! $user ) {
    error_log( 'User lookup failed for ID: ' . $user_id );
    wp_send_json_error( 'User not found' );
}
```

## Dangerous Function Catalog

These functions require extra scrutiny when used with user input.

| Function | Risk | Secure Alternative |
|----------|------|-------------------|
| `eval()` | Code injection | Avoid; refactor logic |
| `assert()` | Code injection (PHP 7) | Use proper conditionals |
| `exec()` | Command injection | Avoid; use WP functions |
| `shell_exec()` | Command injection | Avoid; use WP functions |
| `system()` | Command injection | Avoid; use WP functions |
| `passthru()` | Command injection | Avoid; use WP functions |
| `unserialize()` | Object injection | `json_decode()` |
| `include()` / `require()` with user input | Path traversal | Whitelist approach |
| `file_get_contents()` with user path | Path traversal | Validate with `realpath()` |
| `move_uploaded_file()` | File upload bypass | `wp_handle_upload()` |
| `preg_replace()` with /e modifier | Code injection | Use preg_replace_callback() |
| `extract()` | Variable overwriting | Access array keys directly |
| `parse_str()` without 2nd arg | Variable overwriting | Always use 2nd parameter |
| `create_function()` | Code injection | Use anonymous functions |
| `file()` / `readfile()` with URLs | SSRF | Validate/whitelist URLs |
| `curl_exec()` with user URL | SSRF | Validate/whitelist URLs |

```php
// ❌ BAD: exec() with user input
$filename = $_GET['file'];
exec( 'cat ' . $filename, $output ); // Command injection!

// ✅ GOOD: Avoid shell commands; use PHP
$filename = basename( sanitize_file_name( $_GET['file'] ) );
$path = WP_CONTENT_DIR . '/files/' . $filename;
if ( file_exists( $path ) ) {
    $output = file( $path );
}
```

## Summary

This reference catalogs WordPress security vulnerabilities with detection patterns and secure alternatives. Key principles:

1. **Use parameterized queries** — Never interpolate variables in SQL
2. **Escape late** — Sanitize input, escape output in correct context
3. **Verify nonces** — All state-changing operations need CSRF protection
4. **Check capabilities** — Use meta capabilities with object context
5. **Use WordPress functions** — wp_handle_upload(), wp_safe_redirect(), etc.
6. **Never trust user input** — Validate, sanitize, whitelist, escape
7. **Avoid dangerous functions** — No unserialize(), exec(), eval() on user data

Cross-references:
- Detailed escaping patterns → escaping-guide.md
- Detailed sanitization patterns → sanitization-guide.md
- Detailed nonce patterns → nonce-csrf-guide.md
- Detailed authorization patterns → auth-patterns.md
